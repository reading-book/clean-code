## Chapter 17. 냄새와 휴리스틱: 클린코드 규칙들 총정리

### 1. 철학
#### 나쁜 코드가 나쁜 이유  

<img width="279" alt="스크린샷 2021-11-28 오후 11 11 33" src="https://user-images.githubusercontent.com/83348294/143771474-599ed8f1-1b21-4449-8ab3-f3c9f2cc409f.png">  

#### 생산성 저하  
- 나쁜 코드는 팀 생산성을 저하시킨다.  
- 기술부채를 만들어 수정을 더 어렵게 한다.

#### 클린 코드
- 성능이 좋은 코드
- 의미가 명확한 코드 = 가독성이 좋은 코드
- 중복이 제거된 코드

생산성 상승!

#### 창발적 설계 4번째 규칙: 실용적 관점에서 타협한다.
과도한 설계 NO!
- 여러가지 규칙에 극단적으로 심취해 클래스와 메서드를 무수하게 만들지 말라.
- 결국 좋은 코드를 만드는 이유는 생산성을 올리기 위한 것이다.
- 실용적인 관점에서 타협해야 한다.  
  
"개집 짓는데 사람 집 지으면 안된다."

#### 보이스카우트 룰
"전보다 더 깨끗한 코드로 만든다."

### 2. 공동 창작 매너
함께 코드를 공동 창작하고 소비하는 나와 동료 개발자들을 위한 매너  
  
Team Coding Convention - 팀의 코딩 스타일에 관한 약속  
  
우리 팀의 컨벤션이 가장 중요하다!  

### 3. 객체 지향 패턴

#### 캡슐화 (Encapsulation)
객체의 실제 구현을 외부로부터 감추는 방식
<img width="387" alt="스크린샷 2021-11-28 오후 11 17 57" src="https://user-images.githubusercontent.com/83348294/143771706-1b792be2-b54f-4ee1-b1c6-eb6b212d4638.png">

#### 외부 코드와 호환하기 - Adapter 패턴
외부 코드를 호출할 때, 우리가 정의한 인터페이스 대로 호출하기 위해 사용하는 패턴
<img width="248" alt="스크린샷 2021-11-28 오후 11 18 34" src="https://user-images.githubusercontent.com/83348294/143771726-551947cb-0652-42e8-9691-d30b4249ad01.png">

#### 높은 결합도, 낮은 응집도
<img width="343" alt="스크린샷 2021-11-28 오후 11 18 55" src="https://user-images.githubusercontent.com/83348294/143771745-0de0554f-7abb-4099-90ac-ed4dd678b024.png">

#### SOLID 원칙
객체지향 설계의 5가지 원칙
<img width="220" alt="스크린샷 2021-11-28 오후 11 19 18" src="https://user-images.githubusercontent.com/83348294/143771769-8d4403f5-c6db-453d-8094-e7c4b3ad50fe.png">
- SRP 단일 책임 원칙
- OCP 개방-폐쇄 원칙
- LSP 리스코프 치환 원칙
- ISP 인터페이스 분리 원칙
- DIP 의존성 역전 원칙

#### SRP(단일 책임 원칙)
한 클래스는 하나의 책임만 가져야 한다.  
<img width="271" alt="스크린샷 2021-11-28 오후 11 20 15" src="https://user-images.githubusercontent.com/83348294/143771801-76f936d2-1e82-46c2-89f1-559484a31dd2.png">  
- 클래스는 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- SRP 책임이 분명해지기 때문에, 변경에 의한 연쇄작용에서 자유로워질 수 있다.
- 가독성 향상과 유지보수가 용이해진다.
- 실전에서는 쉽지 않지만 늘 상기해야 한다!

#### OCP(개방-폐쇄 원칙)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.  
<img width="292" alt="스크린샷 2021-11-28 오후 11 21 28" src="https://user-images.githubusercontent.com/83348294/143771866-a9233552-4bcb-4cd0-8a51-5e6d0f26747e.png">  
- 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 가능한 극대화 해야 한다.
- 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성 요소를 쉽게 확장해서 재사용한다.
- 객체지향의 추상화와 다형성을 활용한다.

#### LSP(리스코프 치환 원칙)
서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.  
<img width="243" alt="스크린샷 2021-11-28 오후 11 22 43" src="https://user-images.githubusercontent.com/83348294/143771920-aab91269-68e1-4416-a17e-3de87b5453d5.png">  
- 서브 타입은 기반 타입이 약속한 규약(접근제한자, 예외 포함)을 지켜야 한다.
- 클래스 상속, 인터페이스 상속을 이용해 확장성을 획득한다.
- 다형성과 확장성을 극대화하기 위해 인터페이스를 사용하는 것이 더 좋다.
- 합성(composition)을 이용할 수도 있다.

#### ISP(인터페이스 분리 원칙)
자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.  
<img width="300" alt="스크린샷 2021-11-28 오후 11 23 54" src="https://user-images.githubusercontent.com/83348294/143771958-00fa1298-33ff-434a-9cc2-24628857953d.png">  
- 가능한 최소한의 인터페이스만 구현한다.
- 만약 어떤 클래스를 이용하는 클라이언트가 여러 개고, 이들이 클래스의 특정 부분만 이용한다면 여러 인터페이스로 분류하여 클라이언트가 필요한 기능만 전달한다.
- SRP가 클래스의 단일 책임이라면, ISP는 인터페이스의 단일 책임

#### DIP(의존성 역전 원칙)
상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.  
추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상화에 따라 달라진다.  
<img width="308" alt="스크린샷 2021-11-28 오후 11 26 09" src="https://user-images.githubusercontent.com/83348294/143772055-4c4c75b2-48bb-42d6-aeae-70071baeea05.png">  
- 하위 모델의 변경이 상위 모듈의 변경을 요구하는 위계관계를 끊는다.
- 실제 사용관계는 그대로이지만, 추상화를 매개로 메시지를 주고 받으면서 관계를 느슨하게 만든다.

### 4. 오류 

#### Unchecked Exception을 사용하자
안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지는 않다는 사실이 분명해졌다.  
C#은 확인된 예외를 지원하지 않는다. 영웅적인 시도에도 불구하고 C++역시 확인된 예외를 지원하지 않는다.  
파이썬이나 루비도 마찬가지다.  
그럼에도 불구하고 C#, C++, 파이썬, 루비는 안정적인 소프트웨어를 구현하기에 무리가 없다.

#### Exception 가계도
Checked vs Unchecked Exception
- Exception을 상속하면 Checked Exception 명시적인 예외처리가 필요하다. ex. IOException, SQLException
- RuntimeException을 상속하면 UncheckedException 명시적인 예외처리가 필요하지 않다. ex. NullPointerException, IllegalArgumentException, IndexOutOfBoundException

#### 실무 예외 처리 패턴
getOrElse: 예외 대신 기본 값을 리턴한다.
1. null이 아닌 기본 값
2. 도메인에 맞는 기본 값  
  
getOrElseThrow: null 대신 예외를 던진다. (기본 값이 없다면)

### 5. 테스트

#### Test Pyramid
<img width="305" alt="스크린샷 2021-11-28 오후 11 32 15" src="https://user-images.githubusercontent.com/83348294/143772255-6b33fb8e-50e7-4be7-8c10-76fba85e3203.png">  
  
1. Unit Test: 프로그램 내부의 개별 컴포넌트의 동작을 테스트한다. 배포하기 전에 자동으로 실행되도록 많이 사용한다.
2. Intergration Test: 프로그램 내부의 개별 컴포넌트들을 합쳐서 동작을 테스트한다. Unit Test는 각 컴포넌트를 고립시켜 테스트하기 때문에 컴포넌트의 interaction을 확인하는 Intergration Test가 필요하다.
3. E2E Test: End to End test. 실제 유저의 시나리오대로 네트워크를 통해 서버의 Endpoint를 호출해 테스트한다.

### FIRST 원칙
<img width="272" alt="스크린샷 2021-11-28 오후 11 34 27" src="https://user-images.githubusercontent.com/83348294/143772334-7d9803c9-fd43-41ef-b288-a6611b348df0.png">  
  
1. Fast: 빠르게  
테스트는 빨리 돌아야 한다. 자주 돌려야 하기 때문이다.  
2. Independent: 독립적으로  
각 테스트를 독립적으로 작성한다. 서로에게 의존하면 실패한 원인을 찾기 어려워진다. (다른 테스트의 실패로 인한건지, 코드 오류인지)  
3. Repeatable: 반복 가능하게  
테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 모든 환경에서 돌아가야 한다.  
4. Self-Balidating: 자가검증하는  
테스트는 bool 값으로 결과를 내야 한다.  
5. Timely: 적시에  
테스트하려는 실제 코드를 구현하기 직전에 구현한다.  

### 6. 개선

#### 점진적으로 개선하기
1. 앗! 뭔가 잘못되고 있어! : 코드가 나빠지고 있음을 느꼈을 때 기능을 추가하지 않고 개선을 시작한다.
2. 테스트코드를 작성한다. : 변경을 가한 후에도 시스템이 변경 전과 똑같이 돌아가야 한다. 테스트 코드가 없다면 작성하고, 코드를 수정하기 전 상태에서 모든 테스트가 통과해야 한다.
3. 점진적으로 개선한다. : 책임에 따라 클래스를 나누고 코드를 옮긴다. 테스트가 깨지지 않도록 확인하며 자잘한 변경을 조금씩 진행한다.

"프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위다."

#### 코드에 접근하는 시각
오픈 소스 접근법  
Spring 프로젝트 접근법

### + IDE 활용

#### IDE를 활용해 점진적으로 개선하기
코드 블럭을 메서드로 추출할 수 있다.

#### IDE Code Analysis 기능
클래스가 선언된 .java .kt 파일 선택 후 우클릭 > Diagrams  
연관된 클래스들을 클래스 다이어그램으로 볼 수 있다!
